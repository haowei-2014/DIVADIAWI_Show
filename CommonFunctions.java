package ch.unifr.diuf.diva.gabor;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * @author hao
 *
 * This class contains common functions used by Split, Merge, and Crop functions. 
 */
public class CommonFunctions {

    protected CommonFunctions() {
    }

    /**
     * Delete a folder and the files inside it. It is potentially used to delete temporary data generated by Matlab.
     * 
     * @param folder
     */
    public static void deleteFolder(File folder) {
        File[] files = folder.listFiles();
        if (files != null) { //some JVMs return null for empty dirs
            for (File f : files) {
                if (f.isDirectory()) {
                    deleteFolder(f);
                } else {
                    f.delete();
                }
            }
        }
        folder.delete();
    }


    /**
     * This function is to convert the values of pixels on the image to either 0 or 255.
     *
     * @param inputImage
     * @return
     */
    public static BufferedImage convertImage(BufferedImage inputImage) {
        BufferedImage outputImage = new BufferedImage(inputImage.getWidth(), inputImage.getHeight(),
                BufferedImage.TYPE_BYTE_GRAY);
        int[] iArray = new int[1];

        WritableRaster raster = outputImage.getRaster();
        for (int i = 0; i < inputImage.getHeight(); i++) {
            for (int j = 0; j < inputImage.getWidth(); j++) {
                if (inputImage.getRaster().getSample(j, i, 0) < 125) {
                    iArray[0] = 0;
                    raster.setPixel(j, i, iArray);
                } else {
                    iArray[0] = 255;
                    raster.setPixel(j, i, iArray);
                }
            }
        }
        return outputImage;
    }

    /**
     * adjust the position of polygon, as the polygon obtained by ijblob has an offset which is
     * one pixel to the right and one pixel to the bottom.
     *
     * @param inputP
     * @return
     */
    public static Polygon adjustPolygon(Polygon inputP) {
        Polygon outputP = new Polygon();
        int[] dstXPoints = new int[inputP.xpoints.length];
        int[] dstYPoints = new int[inputP.ypoints.length];
        for (int i = 0; i < dstXPoints.length; i++) {
            dstXPoints[i] = inputP.xpoints[i] - 1;
        }
        for (int i = 0; i < dstYPoints.length; i++) {
            dstYPoints[i] = inputP.ypoints[i] - 1;
        }

        outputP.xpoints = dstXPoints;
        outputP.ypoints = dstYPoints;
        outputP.npoints = inputP.npoints;
        return outputP;
    }

    public static List<Point> getBoundaryPoints(Polygon p) {
        List<Point> points = new ArrayList<>();
        for (int i = 0; i < p.npoints; i++) {
            points.add(new Point(p.xpoints[i], p.ypoints[i]));
        }
        return points;
    }

    /**
     * Draw rectangles and polygons.
     *
     * @param path
     * @param img
     * @param rects
     * @param polygons
     * @param name
     */
    public static void drawBoundaries(String path, BufferedImage img, List<Rectangle> rects,
                                      List<Polygon> polygons, List<Polygon> gt, String name) {
        BufferedImage imgShow = new BufferedImage(img.getWidth(), img.getHeight(),
                BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = imgShow.createGraphics();
        g2d.drawImage(img, 0, 0, null);
        if (rects != null) {
            g2d.setColor(Color.blue);
            for (Rectangle rect : rects) {
                g2d.drawRect(rect.x, rect.y, rect.width, rect.height);
            }
        }
        if (polygons != null) {
            g2d.setColor(Color.red);
            g2d.setStroke(new BasicStroke(2));  // set stroke width
            for (Polygon p : polygons) {
                g2d.drawPolygon(p);
            }
        }
        if (gt != null) {
            g2d.setColor(Color.green);
            for (Polygon p : gt) {
                g2d.drawPolygon(p);
            }
        }
        g2d.dispose();
        try {
            File file = new File(path + name);
            if (file.exists()) {
                file.delete();
            }
            ImageIO.write(imgShow, "png", file);
        } catch (IOException e) {
//			e.printStackTrace();
        }
    }

    /**
     * link the polygon pair (left and right one) with a polygon.
     * 
     * @param img
     * @param polygonLeft
     * @param polygonRight
     * @param rect
     * @return
     */
    public static BufferedImage drawRects(BufferedImage img, Polygon polygonLeft, Polygon polygonRight, Rectangle rect) {
        BufferedImage imgShow = new BufferedImage(img.getWidth(),
                img.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = imgShow.createGraphics();
        g2d.drawImage(img, 0, 0, null);
        g2d.setColor(Color.black);

        // get the left top and left bottom points where the rectangle intersects its left polygon
        ArrayList<Point> leftPoints = new ArrayList<Point>();
        int numberPoints = polygonLeft.npoints;
        for (int i = 0; i < numberPoints; i++) {
            leftPoints.add(new Point(polygonLeft.xpoints[i],
                    polygonLeft.ypoints[i]));
        }
        int leftTop = 10000;
        int leftBottom = 0;
        for (Point point : leftPoints) {
            if (point.x == rect.x && leftTop > point.y) {
                leftTop = point.y;
            }
            if (point.x == rect.x && leftBottom < point.y) {
                leftBottom = point.y;
            }
        }
        // in case that the linking rectangle completely contains its left polygon.
        if (leftTop == 10000) {
            for (Point point : leftPoints) {
                if (point.x == polygonLeft.getBounds().x
                        + polygonLeft.getBounds().width / 2
                        && leftTop > point.y) {
                    leftTop = point.y;
                }
                if (point.x == polygonLeft.getBounds().x
                        + polygonLeft.getBounds().width / 2
                        && leftBottom < point.y) {
                    leftBottom = point.y;
                }
            }
        }
        if (leftTop < 0) {
            leftTop = 0;
        }
        // get the right top and right bottom points where the rectangle intersects its right polygon
        ArrayList<Point> rightPoints = new ArrayList<Point>();
        numberPoints = polygonRight.npoints;
        for (int i = 0; i < numberPoints; i++) {
            rightPoints.add(new Point(polygonRight.xpoints[i],
                    polygonRight.ypoints[i]));
        }
        int rightTop = 10000;
        int rightBottom = 0;
        for (Point point : rightPoints) {
            if (point.x == (rect.x + rect.width) && rightTop > point.y) {
                rightTop = point.y;
            }
            if (point.x == (rect.x + rect.width) && rightBottom < point.y) {
                rightBottom = point.y;
            }
        }
        // in case that the linking rectangle completely contains its right polygon.
        if (rightTop == 10000) {
            for (Point point : rightPoints) {
                int tmpX = polygonRight.getBounds().x
                        + polygonRight.getBounds().width / 2;
                if (point.x == tmpX
                        && rightTop > point.y) {
                    rightTop = point.y;
                }
                if (point.x == tmpX
                        && rightBottom < point.y) {
                    rightBottom = point.y;
                }
            }
        }
        if (rightTop < 0) {
            rightTop = 0;
        }
        // shrink the linking polygon by lowering its top vertexes and lifting its bottom vertexes.
        if (leftBottom > leftTop + 6) {
            leftBottom -= 3;
            leftTop += 3;
        }
        if (rightBottom > rightTop + 6) {
            rightBottom -= 3;
            rightTop += 3;
        }

        // fill the polygon with the black color
        Polygon linkingPolygon = new Polygon();
        linkingPolygon.addPoint(rect.x, leftTop);
        linkingPolygon.addPoint(rect.x + rect.width, rightTop);
        linkingPolygon.addPoint(rect.x + rect.width, rightBottom);
        linkingPolygon.addPoint(rect.x, leftBottom);
        g2d.fillPolygon(linkingPolygon);

//		g2d.setColor(Color.green);
//		g2d.drawPolygon(linkingPolygon);
//		g2d.drawRect(rect.x, rect.y, rect.width, rect.height);
/*		
        if (rightTop == 10000){
			g2d.setColor(Color.red);
			g2d.fillPolygon(polygonLeft);
			g2d.fillPolygon(polygonRight);
			g2d.setColor(Color.green);
			g2d.drawRect(rect.x, rect.y, rect.width, rect.height);
		}*/
        return imgShow;
    }

    
    /**
     * link the polygon pair (left and right one) with a polygon.
     * 
     * @param img
     * @param polygonLeft
     * @param polygonRight
     * @param rect
     * @return
     */
    public static BufferedImage drawRectsMerge(BufferedImage img, Polygon polygonLeft, Polygon polygonRight, Rectangle rect) {
        BufferedImage imgShow = new BufferedImage(img.getWidth(),
                img.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = imgShow.createGraphics();
        g2d.drawImage(img, 0, 0, null);
        g2d.setColor(Color.black);

        // get the left top and left bottom points where the rectangle intersects its left polygon
        ArrayList<Point> leftPoints = new ArrayList<Point>();
        int numberPoints = polygonLeft.npoints;
        for (int i = 0; i < numberPoints; i++) {
            leftPoints.add(new Point(polygonLeft.xpoints[i],
                    polygonLeft.ypoints[i]));
        }
        int leftTop = 10000;
        int leftBottom = 0;
        for (int i = 0; i < leftPoints.size() - 1; i++) {
            if ((rect.x >= leftPoints.get(i).x && rect.x < leftPoints.get(i + 1).x) ||
                    (rect.x <= leftPoints.get(i).x && rect.x > leftPoints.get(i + 1).x)) {
                if (leftTop > leftPoints.get(i).y) {
                    leftTop = leftPoints.get(i).y;
                }
                if (leftBottom < leftPoints.get(i).y) {
                    leftBottom = leftPoints.get(i).y;
                }
            }
        }
        // in case that the linking rectangle completely contains its left polygon.
        if (leftTop == 10000) {
            for (Point point : leftPoints) {
                if (point.x == polygonLeft.getBounds().x
                        + polygonLeft.getBounds().width / 2
                        && leftTop > point.y) {
                    leftTop = point.y;
                }
                if (point.x == polygonLeft.getBounds().x
                        + polygonLeft.getBounds().width / 2
                        && leftBottom < point.y) {
                    leftBottom = point.y;
                }
            }
        }
        if (leftTop < 0) {
            leftTop = 0;
        }
        // get the right top and right bottom points where the rectangle intersects its right polygon
        ArrayList<Point> rightPoints = new ArrayList<Point>();
        numberPoints = polygonRight.npoints;
        for (int i = 0; i < numberPoints; i++) {
            rightPoints.add(new Point(polygonRight.xpoints[i],
                    polygonRight.ypoints[i]));
        }
        int rightTop = 10000;
        int rightBottom = 0;
        for (int i = 0; i < rightPoints.size() - 1; i++) {
            if (((rect.x + rect.width) >= rightPoints.get(i).x && (rect.x + rect.width) < rightPoints.get(i + 1).x) ||
                    ((rect.x + rect.width) <= rightPoints.get(i).x && (rect.x + rect.width) > rightPoints.get(i + 1).x)) {
                if (rightTop > rightPoints.get(i).y) {
                    rightTop = rightPoints.get(i).y;
                }
                if (rightBottom < rightPoints.get(i).y) {
                    rightBottom = rightPoints.get(i).y;
                }
            }
        }

        // in case that the linking rectangle completely contains its right polygon.
        if (rightTop == 10000) {
            for (Point point : rightPoints) {
                int tmpX = polygonRight.getBounds().x
                        + polygonRight.getBounds().width / 2;
                if (point.x == tmpX
                        && rightTop > point.y) {
                    rightTop = point.y;
                }
                if (point.x == tmpX
                        && rightBottom < point.y) {
                    rightBottom = point.y;
                }
            }
        }
        if (rightTop < 0) {
            rightTop = 0;
        }
        // shrink the linking polygon by lowering its top vertexes and lifting its bottom vertexes.
        if (leftBottom > leftTop + 6) {
            leftBottom -= 3;
            leftTop += 3;
        }
        if (rightBottom > rightTop + 6) {
            rightBottom -= 3;
            rightTop += 3;
        }

        // fill the polygon with the black color
        Polygon linkingPolygon = new Polygon();
        linkingPolygon.addPoint(rect.x, leftTop);
        linkingPolygon.addPoint(rect.x + rect.width, rightTop);
        linkingPolygon.addPoint(rect.x + rect.width, rightBottom);
        linkingPolygon.addPoint(rect.x, leftBottom);
        g2d.fillPolygon(linkingPolygon);

        return imgShow;
    }

    /**
     * Draw rectangles on the image, and save it to the hard disk
     * @param img
     * @param rects
     * @param name
     */
    public static void drawRects(BufferedImage img, List<Rectangle> rects, String name) {
        BufferedImage imgShow = new BufferedImage(img.getWidth(), img.getHeight(),
                BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = imgShow.createGraphics();
        g2d.drawImage(img, 0, 0, null);
        if (rects != null) {
            g2d.setColor(Color.red);
//			g2d.setColor(Color.black);
            for (Rectangle rect : rects) {
                g2d.drawRect(rect.x, rect.y, rect.width, rect.height);
//				g2d.fillRect(rect.x, rect.y, rect.width, rect.height);
            }
        }
        try {
            File file = new File("/home/hao/workspace/DIVADIAWeb2/DIVADIAGTWeb/WorkData/" + name);
            if (file.exists()) {
                file.delete();
            }
            ImageIO.write(imgShow, "png", file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * This function is: pick up every a few points on the original
     * polygon boundary and construct a new polygon
     *
     * @param polygon
     * @return
     */
    public static Polygon resamplePolygon(Polygon polygon) {
        ArrayList<Point> points = new ArrayList<Point>();
        int numberPoints = polygon.npoints;
        for (int i = 0; i < numberPoints; i++) {
            points.add(new Point(polygon.xpoints[i], polygon.ypoints[i]));
        }

        int interval = 20; // pick up points every interval points
        int newNumberPoints = (numberPoints - 1) / interval + 1; // number of boundary points on the new polygon
        int[] xNewPoints = new int[(numberPoints - 1) / interval + 1];
        int[] yNewPoints = new int[(numberPoints - 1) / interval + 1];
        int newIndex = 0;
        for (int i = 0; i < numberPoints; i++) {
            if (i % interval == 0) {
                xNewPoints[newIndex] = points.get(i).x;
                yNewPoints[newIndex] = points.get(i).y;
                newIndex++;
            }
        }
        return new Polygon(xNewPoints, yNewPoints, newNumberPoints);
    }
}
